import heapq

class PuzzleNode:
    def __init__(self, state, parent=None, move="", depth=0, cost=0):
        self.state = state
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = cost  # f(n) = g(n) + h(n)

    def __lt__(self, other):
        return self.cost < other.cost

def manhattan_distance(state, goal):
    distance = 0
    for num in range(1, 9):
        i, j = divmod(state.index(num), 3)
        x, y = divmod(goal.index(num), 3)
        distance += abs(i - x) + abs(j - y)
    return distance

def get_neighbors(state):
    neighbors = []
    index = state.index(0)
    row, col = divmod(index, 3)

    moves = {
        'Up': (row - 1, col),
        'Down': (row + 1, col),
        'Left': (row, col - 1),
        'Right': (row, col + 1),
    }

    for move, (r, c) in moves.items():
        if 0 <= r < 3 and 0 <= c < 3:
            new_index = r * 3 + c
            new_state = list(state)
            new_state[index], new_state[new_index] = new_state[new_index], new_state[index]
            neighbors.append((tuple(new_state), move))
    return neighbors

def a_star(start, goal):
    open_list = []
    visited = set()

    start_node = PuzzleNode(start, cost=manhattan_distance(start, goal))
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)

        if current_node.state == goal:
            return reconstruct_path(current_node)

        visited.add(current_node.state)

        for neighbor_state, move in get_neighbors(current_node.state):
            if neighbor_state in visited:
                continue

            g = current_node.depth + 1
            h = manhattan_distance(neighbor_state, goal)
            neighbor_node = PuzzleNode(neighbor_state, current_node, move, g, g + h)

            heapq.heappush(open_list, neighbor_node)

    return None

def reconstruct_path(node):
    path = []
    while node.parent:
        path.append(node.move)
        node = node.parent
    path.reverse()
    return path

def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

# Example usage
if __name__ == "__main__":
    start = (1, 2, 3,
             4, 0, 5,
             6, 7, 8)

    goal = (1, 2, 3,
            4, 5, 6,
            7, 8, 0)

    print("Initial state:")
    print_state(start)

    path = a_star(start, goal)

    if path:
        print("Solution found in", len(path), "moves:")
        print(" -> ".join(path))
    else:
        print("No solution found.")
